---
title: "Friday Code Challenge"
output: html_document
date: "2025-05-08"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Stable Matching:

Given N hospitals with a certain number of available positions and N medical students 
looking for a position at a hospital. Each hospital has its ranking of the students 
in order of preference, and each student has the ranking of the hospitals in order 
of preference. The goal is to write a function(s) to find a stable assignment where 
each student is assigned to at most one hospital so that all available positions in 
all hospitals are filled.

We say that an assignment is stable if no instability of the following two types exists:
- There is a hospital h and students s and s′ so that: s is assigned to h; s′ is 
not assigned to any hospital; and h prefers s′ to s.
- There are hospitals h and h′, and students s and s′ so that: s is assigned to h; 
s′ is assigned to h′; h prefers s′ to s; and s′ prefers h to h′

Examples:
Given a 2NxN preference list where row [1,] to [N,] is hospital 1 to N’s preference 
list of students and row [N+1,] to [2N] is student N+1 to 2N’s preference list of 
hospitals we have the following matrix and result:

The matrix:
    [,1] [,2] [,3]
[1,]    4     5    6
[2,]    5     4    6
[3,]    4     6    5
[4,]    2     1    3
[5,]    3     2    1
[6,]    1     2    3
 
	
The output:

Students:Hospitals

4:1

5:2

6:3
 
Explanation:
Hospital 1 and student 4 mutually prefer each other, forming a stable pair. 
Similarly, hospital 2 pairs with student 5, and hospital 3 is matched with 
student 6, ensuring a stable arrangement.
 
Code to produce example above:
matrix(c(4,5,6,5,4,6,4,6,5,2,1,3,3,2,1,1,2,3), nrow = 6, ncol = 3, byrow = T)
 
Helper code to generate a bunch of variety of inputs:

set.seed(123)
num_of_matches <- 10
pref_list <- t(
  cbind(
    replicate(num_of_matches, sample((num_of_matches+1):(2*num_of_matches))),
    replicate(num_of_matches, sample(1:num_of_matches, num_of_matches))
  )
)


``` {r}

# Helper code to generate a bunch of variety of inputs:

match_matrix <- matrix(c(4,5,6,5,4,6,4,6,5,2,1,3,3,2,1,1,2,3), nrow = 6, ncol = 3, byrow = T)

set.seed(123)
num_of_matches <- 10
pref_list <- t(
  cbind(
    replicate(num_of_matches, sample((num_of_matches+1):(2*num_of_matches))),
    replicate(num_of_matches, sample(1:num_of_matches, num_of_matches))
  )
)

hospital_assignment <- function(match_matrix) {
  
  n <- nrow(match_matrix)/2
  
  available_hospitals <- 1:n
  
  available_students <- (n+1):(2*n)
  
  matched_pairs <- matrix(, ncol = 2, byrow = T)
  colnames(matched_pairs) <- c("hospital", "student")
  
  #fill first hosptial based on priority student
  while(length(available_hospitals) > 0) {
    
    hospital_index <- available_hospitals[1]
    
    priority_students <- match_matrix[hospital_index,]
    
    priority_student <- priority_students[which(priority_students %in% available_students)][1]
    
    matched_pair <- matrix(c(hospital_index, priority_student), ncol = 2, byrow = T)
    
    matched_pairs <- rbind(matched_pairs, matched_pair)
    
    available_hospitals <- available_hospitals[-1]
    available_students <- available_students[which(!available_students %in% priority_student)]
    
    ## need to add a check for the priority student to see if it matches better with a hospital
    
  }
  
  
  return(matched_pairs[-1,])
  
  #remove that student from the available
  
  #continue through hospitals 
  
  #if run into a hospital with no matches
  #cycle through prior hospitals and assign student from their matches that still
  #available
  
}

set.seed(123)
num_of_matches <- 10
pref_list <- t(
  cbind(
    replicate(num_of_matches, sample((num_of_matches+1):(2*num_of_matches))),
    replicate(num_of_matches, sample(1:num_of_matches, num_of_matches))
  )
)

hospital_assignment(pref_list)


```


